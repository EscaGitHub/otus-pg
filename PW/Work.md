# Подключение и настройка балансировщика нагрузки и мониторинга PostgreSQL

## Введение
Создание соединения с базой данных PostgreSQL для выполнения запросов обходится довольно дорого. Накладные расходы 
составляют около 1.3MB - 2MB памяти на одно соединение. Так же каждый раз нужны ресурсы для созданий [новых процессов
на сервере БД](https://www.postgresql.org/docs/current/connect-estab.html). Каждый клиент подключается к новому процессу,
которыми управляет postmaster. Всякий раз, когда он обнаруживает запрос на соединение, он запускает новый внутренний 
процесс. При большом количестве клиентских соединений БД создает множество процессов и управляет разделяемыми 
структурами данных. Из-за этого может возникнуть нехватка вычислительных ресурсов, которая сказывается на производительности.

Чтобы решить проблему нехватки ресурсов, перед кластером PostgreSQL часто размещают менеджеры подключений (connection 
pooler). Менеджеры подключений управляют соединениями, позволяя подключиться к БД большому числу клиентов без деградации
производительности. Между менеджером подключений и СУБД поддерживается относительно небольшое количество соединений, 
которые можно переиспользовать. После отключения клиента соединение возвращается в пул и может быть повторно использовано
тем же самым или новым клиентом.
<img src="./pic/pools.png" alt="drawing" width="1051"/>

## Виды

### [Pgpool-II](https://www.pgpool.net/)

- Если нам требуется N параллельных соединений, это создает N дочерних процессов. По умолчанию существует 32 дочерних процесса.
- Определяет один процесс для каждого дочернего процесса. Мы не можем контролировать, к какому дочернему процессу подключается клиент.
Клиент получает выгоду от пулового соединения только в том случае, если он подключается к дочернему процессу, который 
ранее обслуживал соединение для этой комбинации БД+пользователь.
- Поддерживает только сессионный режим работы.
- Обеспечивает высокую доступность - автоматическое переключение на реплики.
- Поддерживает автоматическую балансировку нагрузки — он даже достаточно интеллектуален, чтобы перенаправлять запросы на
чтение на реплики и запись на мастер.
- Позволяет ограничивать только общее количество соединений.

### [Pgbouncer](https://www.pgbouncer.org/)

- Использует только один процесс - легковесный.
- Создает новый пул в комбинации пользователя и БД. Поэтому он общий для всех клиентов.
- Поддерживает три вида режима работы:
  - сессионный - клиент получает постоянное подключение к серверу на все время своей сессии. Когда клиент завершает сессию, 
  подключение возвращается в пул. Этот метод является наиболее безопасным и используется по умолчанию.
  - транзакционный - клиент получает подключение только на время выполнения транзакции, после завершения которой 
  подключение возвращается в пул.
  - операторов - самый агрессивный метод. Клиентские подключения возвращается в пул после каждого выполненного запроса. 
  При использовании этого метода нельзя выполнять транзакции, содержащие несколько операторов, поскольку после каждого 
  оператора подключение закрывается.
- Нет балансировки нагрузки.
- Позволяет ограничивать количество подключений для каждого пула, базы данных, пользователя или клиента.
- Сквозная аутентификация

### [Odyssey](https://yandex.ru/dev/odyssey/) - Yandex

- Многопоточная обработка.
- Продвинутый transaction pooling.
- Правильная передача ошибок клиенту.
- Удобное логирование и отладка.
- Детальная настройка пулов.
- Совместимость с консолью Pgbouncer.

## Установка инфраструктуры
### Prometheus
Ставим Prometheus в docker с пробросом файла настроек и данных:
```bash
docker run --name prometheus -p 9090:9090 -v D:\docker\volumes\prometheus.yml:/etc/prometheus/prometheus.yml -v D:\docker\volumes\prometheus-data:/prometheus prom/prometheus
```
Новый запуск контейнера:
```bash
docker start -ai prometheus
```
Доступ
```bash
http://localhost:9090
```

### Grafana
Устанавливаем docker
```bash
docker run -d -p 3000:3000 --name=grafana grafana/grafana-enterprise
```
Доступ (admin admin)
```bash
http://localhost:3000/login
```
Подключаем prometheus из докера: 
+ Home -> Connections -> Data sources -> Выбираем prometheus
+ Т.к. Prometheus в docker необходимо получить его ip
```bash
# Берем CONTAINER ID prometheus:
docker ps -a 
# Порлучаем ip:
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' CONTAINER ID
```
+ В строке 'Prometheus server URL' прописываем полученный адрес до prometheus:
```bash
http://172.17.0.3:9090 
```
+ Импортируем dashboard для метрик prometheus, метрики пошли:
<img src="./pic/metrics_prom.png" alt="drawing" width="1051"/>

### PgBouncer
- Подключаемся к VM
```bash
ssh -i keypair esca@89.169.168.245
```

## Источники
- https://habr.com/ru/articles/499404/ - Управление нагрузкой на PostgreSQL, когда одного сервера уже мало. Андрей Сальников
- https://yandex.cloud/ru/docs/managed-postgresql/concepts/pooling?utm_referrer=https%3A%2F%2Fwww.google.com%2F - Управление соединениями
- https://stackoverflow.blog/2020/10/14/improve-database-performance-with-connection-pooling/ - Improve database 
performance with connection pooling. October 2020.
- https://scalegrid.io/blog/postgresql-connection-pooling-part-4-pgbouncer-vs-pgpool/ - PostgreSQL® Connection Pooling: 
Part 4 – PgBouncer vs. Pgpool-II. Jul 29, 2020.
- https://postgrespro.ru/docs/postgrespro/15/pgbouncer - pgbouncer
- https://hub.docker.com/r/prometheuscommunity/pgbouncer-exporter - prometheuscommunity/pgbouncer-exporter
- https://tembo.io/blog/postgres-connection-poolers - Benchmarking PostgreSQL connection poolers: PgBouncer, PgCat and Supavisor.
Feb 13, 2024